(set-info :smt-lib-version 2.6)
(set-logic QF_UFBV)
(set-info :source |
Generated by: Jaroslav Bendik
Generated on: 2023-03-14
Generator: Certora Prover
Application: Formal verification of Ethereum Smart Contracts
Target solver: z3, cvc4, cvc5
Publications: https://docs.certora.com/en/latest/docs/whitepaper/index.html
This benchmarkset was produced by the Certora Prover, i.e. a tool for
formal verification of Ethereum Smart Contracts.  The benchmarks encode
verification conditions for real Smart Contracts (programs) written by
Certora customers.

The Certora Prover uses various strategies and SMT encodings of the
underlying verification problem. In most cases, we use either LIA,
NIA or BV encodings, where:

1. LIA is typically an overapproximation of the underlying verification
   problem.
2. NIA is typically a precise encoding.
3. BV is required when the input contains non-trivial bitwise operations
   that we do not model precisely with NIA (i.e., in these cases, NIA
   is an overapproximation).

Note that our specification language allows unbounded integers
(i.e. mathints); this the reason why we need NIA and LIA instead of
using just BV.

We also use various encodings of "underlying hashing functions"; the
two main encodings we use rely on i) UF and ii) on UFDT. Therefore,
given a single input (a smart contract and a specification), we typically
produce 6 different encodings: QF_UFNIA, QF_UFLIA, QF_UFBV, QF_UFDTNIA,
QF_UFDTLIA, and QF_UFDTBV. The 462 benchmarks in this benchmark set
originate from 77 unique smart contracts and specifications (77*6 =
462) and can be mapped based on the common name-prefix of the files. For
instances:

./QF_UFBV/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFBV.smt2
./QF_UFDTLIA/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFDTLIA.smt2
./QF_UFLIA/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFLIA.smt2
./QF_UFDTBV/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFDTBV.smt2
./QF_UFDTNIA/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFDTNIA.smt2
./QF_UFNIA/20230314-Jaroslav-Bendik-Certora/940_590f27b1c3c800d3243e_33_QF_UFNIA.smt2
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)
(declare-fun x23 () (_ BitVec 256))
(declare-fun x5 () (_ BitVec 256))
(declare-fun x53 () (_ BitVec 256))
(declare-fun x46 () Bool)
(declare-fun x81 () (_ BitVec 256))
(declare-fun x27 () (_ BitVec 256))
(declare-fun x58 () (_ BitVec 256))
(declare-fun x20 ((_ BitVec 256)) (_ BitVec 256))
(declare-fun x26 () (_ BitVec 256))
(declare-fun x39 () (_ BitVec 256))
(declare-fun x42 () (_ BitVec 256))
(declare-fun x21 () (_ BitVec 256))
(declare-fun x25 () (_ BitVec 256))
(declare-fun x8 () Bool)
(declare-fun x62 () (_ BitVec 256))
(declare-fun x67 () (_ BitVec 256))
(declare-fun x41 () (_ BitVec 256))
(declare-fun x7 () Bool)
(declare-fun x54 () (_ BitVec 256))
(declare-fun x44 () Bool)
(declare-fun x55 () (_ BitVec 256))
(declare-fun x37 () Bool)
(declare-fun x6 () (_ BitVec 256))
(declare-fun x45 () (_ BitVec 256))
(declare-fun x65 ((_ BitVec 256)) (_ BitVec 256))
(declare-fun x4 () (_ BitVec 256))
(declare-fun x9 () (_ BitVec 256))
(declare-fun x17 () (_ BitVec 256))
(declare-fun x36 () (_ BitVec 256))
(declare-fun x38 () (_ BitVec 256))
(declare-fun x15 () (_ BitVec 256))
(declare-fun x30 () (_ BitVec 256))
(declare-fun x64 () (_ BitVec 256))
(declare-fun x18 () (_ BitVec 256))
(declare-fun x47 () Bool)
(declare-fun x89 () (_ BitVec 256))
(declare-fun x93 () (_ BitVec 256))
(declare-fun x1 () (_ BitVec 256))
(declare-fun x73 () (_ BitVec 256))
(declare-fun x92 () (_ BitVec 256))
(declare-fun x76 () (_ BitVec 256))
(declare-fun x59 () (_ BitVec 256))
(declare-fun x40 () (_ BitVec 256))
(declare-fun x50 () (_ BitVec 256))
(declare-fun x84 () (_ BitVec 256))
(declare-fun x75 () (_ BitVec 256))
(declare-fun x72 () (_ BitVec 256))
(declare-fun x13 () (_ BitVec 256))
(declare-fun x12 () (_ BitVec 256))
(declare-fun x70 () (_ BitVec 256))
(declare-fun x51 () (_ BitVec 256))
(declare-fun x74 ((_ BitVec 256)) (_ BitVec 256))
(declare-fun x28 () (_ BitVec 256))
(declare-fun x88 () (_ BitVec 256))
(declare-fun x48 () (_ BitVec 256))
(declare-fun x32 () (_ BitVec 256))
(declare-fun x78 () (_ BitVec 256))
(declare-fun x10 () (_ BitVec 256))
(declare-fun x77 () (_ BitVec 256))
(declare-fun x29 () (_ BitVec 256))
(declare-fun x34 () (_ BitVec 256))
(declare-fun x87 () (_ BitVec 256))
(declare-fun x2 () (_ BitVec 256))
(declare-fun x61 () (_ BitVec 256))
(declare-fun x56 () (_ BitVec 256))
(declare-fun x43 () Bool)
(declare-fun x49 () (_ BitVec 256))
(declare-fun x69 () (_ BitVec 256))
(declare-fun x35 () (_ BitVec 256))
(declare-fun x86 () (_ BitVec 256))
(declare-fun x85 () (_ BitVec 256))
(declare-fun x57 () (_ BitVec 256))
(declare-fun x80 () (_ BitVec 256))
(declare-fun x3 () (_ BitVec 256))
(declare-fun x71 () (_ BitVec 256))
(declare-fun x31 () (_ BitVec 256))
(declare-fun x24 () (_ BitVec 256))
(declare-fun x22 () (_ BitVec 256))
(declare-fun x19 () (_ BitVec 256))
(declare-fun x79 () (_ BitVec 256))
(declare-fun x60 () Bool)
(declare-fun x11 () (_ BitVec 256))
(declare-fun x90 () (_ BitVec 256))
(declare-fun x16 () (_ BitVec 256))
(declare-fun x14 () (_ BitVec 256))
(declare-fun x91 () (_ BitVec 256))
(declare-fun x83 () Bool)
(declare-fun x66 () (_ BitVec 256))
(define-fun x82 ((x33 (_ BitVec 256)) (x52 (_ BitVec 256))) Bool (= (bvudiv (bvmul x33 x52) x52) x33))
(define-fun x68 ((x33 (_ BitVec 256)) (x52 (_ BitVec 256))) Bool (= x33 (bvsdiv (bvmul x33 x52) x52)))
(define-fun x63 ((x33 (_ BitVec 256)) (x52 (_ BitVec 256))) Bool (= x33 (bvsdiv (bvmul x52 x33) x52)))
(assert (not x46))
(assert (= true x47))
(assert (= (=> (and (or (and (and (= x84 (bvadd (bvneg x23) (_ bv2 256))) (= x78 (bvadd (_ bv0 256) (bvneg x69))) (= x89 (bvudiv x16 x69)) (= x72 (bvmul x89 x56)) (= (bvmul x79 x62) x26) (= x23 (bvmul x26 x89)) (bvugt x70 x90) (= (bvadd (bvneg x34) (_ bv2 256)) x79) (= x53 (bvadd (_ bv1 256) x50)) (= (bvmul (_ bv3 256) x89) x9) (= (bvmul x62 x89) x34) (= ((_ extract 255 0) (bvurem (bvmul (concat (_ bv0 256) x19) (concat (_ bv0 256) x59)) (concat (_ bv0 256) x16))) x48) (= x27 (bvadd (_ bv1 256) (bvnot x70))) (= (bvadd x90 (bvneg (ite (bvugt x48 x1) (_ bv1 256) (_ bv0 256)))) x76) (= x73 (bvmul x67 x89)) (= x86 (bvadd (bvneg x73) (_ bv2 256))) (= x66 (bvadd (bvneg x72) (_ bv2 256))) (= x5 (bvmul x84 x26)) (= (bvmul x53 x76) x25) (= x49 (bvmul x5 (bvor x25 x21))) (= x49 x36) (= x56 (bvxor (_ bv2 256) x9)) (= (bvmul x67 x86) x2) (= x80 (bvadd (bvneg x48) x1)) (= x58 (bvmul x2 x89)) (= x67 (bvmul x56 x66)) (= x51 (bvmul x38 x2)) (= (bvudiv x78 x69) x50) (= (bvmul x51 x89) x45) (= (bvadd (_ bv2 256) (bvneg x45)) x42) (= (bvadd (_ bv2 256) (bvneg x58)) x38) (= x69 (bvand x16 x27)) (= (bvudiv x80 x69) x21) (= x62 (bvmul x42 x51))) (not x60)) (and x60 (and (= (bvudiv x1 x16) x3) (= x36 x3) (bvugt x70 (_ bv0 256))))) (and (= (x65 x18) x77) (= x19 x30) (bvugt x39 (_ bv0 256)) (= (_ bv1415856751 256) x24) (= x70 x92) (= x40 x64) (= x60 (= (_ bv0 256) x90)) (= (bvadd (bvneg (ite (bvult x4 x1) (_ bv1 256) (_ bv0 256))) x28) x90) x8 (= x8 (bvugt (x74 x18) (_ bv0 256))) (= (bvmul x19 x59) x1) (= x64 x59) (= x13 x19) (= x70 x16) (bvuge x77 (_ bv0 256)) (= (x74 x18) x39) (bvugt x18 (_ bv0 256)) (= x13 x81) (= x85 x16) (bvuge (_ bv1461501637330902918203684832716283019655932542975 256) x18) (= (bvadd x4 (bvneg x1)) x28) (= x59 x93) (= ((_ extract 255 0) (bvurem (bvmul (concat (_ bv0 256) x19) (concat (_ bv0 256) x59)) (concat (_ bv0 256) (_ bv115792089237316195423570985008687907853269984665640564039457584007913129639935 256)))) x4))) x44) x46))
(assert (= x44 (=> (and (= x36 x6) (and (= x54 x75) (= x15 x41) (= (bvmul x35 x32) x88) (= (= x91 x61) x37) (= x29 x71) (= x57 x22) (= x54 x17) (= x85 x29) (= x35 x31) (= x22 (bvudiv x14 x87)) (= x61 x15) (= x31 x12) (= x91 x10) (= x12 x55) (= x32 x17) (= x88 x14) (= x57 x10) (= x55 x30) (= x11 x71) (= x6 x41) (= x75 x93) (= x11 x87))) x37)))
(assert (= x7 (or x43 x83)))
(assert (= x43 (and (not x60) x47)))
(assert (= (and x60 x47) x83))
(check-sat)
(exit)